import { type NextRequest, NextResponse } from "next/server";

interface Link {
  name: string;
  url: string;
}

/**
 * Converts a GitHub directory URL to a direct .list file URL
 * Example: https://github.com/blackmatrix7/ios_rule_script/tree/master/rule/Clash/ZhihuAds
 * To: https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Clash/ZhihuAds/ZhihuAds.list
 */
function convertToRawListUrl(url: string): string {
  if (!url.includes("github.com")) return url;

  // Replace github.com with raw.githubusercontent.com
  // Remove /tree/ from the URL
  let rawUrl = url.replace("github.com", "raw.githubusercontent.com").replace("/tree/", "/");

  // Append filename.list
  const parts = url.split("/");
  const lastPart = parts[parts.length - 1];
  if (lastPart) {
    rawUrl = `${rawUrl}/${lastPart}.list`;
  }

  return rawUrl;
}

export async function POST(req: NextRequest) {
  try {
    const { links } = (await req.json()) as { links: Link[] };

    if (!links || !Array.isArray(links) || links.length === 0) {
      return NextResponse.json({ error: "No links selected" }, { status: 400 });
    }

    let rosScript = "# Generated by Lilibox RouterOS Exporter\n";
    rosScript += `# Updated: ${new Date().toISOString()}\n`;
    rosScript += "# Configuration: Route traffic via gateway 10.10.10.17\n";
    rosScript += "#\n";
    rosScript += "# IMPORTANT: Before importing this script:\n";
    rosScript += '# 1. Set the vpn_dns_server variable: :global vpn_dns_server "8.8.8.8"\n';
    rosScript += "# 2. Clean up old rules if re-importing:\n";
    rosScript += "#    /routing table remove [find name=vpn_table]\n";
    rosScript += '#    /ip firewall mangle remove [find comment~"VPN"]\n';
    rosScript += '#    /ip route remove [find comment~"VPN"]\n';
    rosScript += '#    /routing rule remove [find comment~"VPN"]\n';
    rosScript += '#    /ip dns static remove [find comment~"vpn-dns"]\n';
    rosScript += "#    /ip firewall address-list remove [find list=vpn_list]\n";
    rosScript += "#\n";
    rosScript += "# 3. To change the gateway, modify the vpn_gateway variable before import\n";
    rosScript += "#\n\n";

    // Global variables
    rosScript += ":global vpn_dns_server\n";
    rosScript += ':global vpn_list "vpn_list"\n';
    rosScript += ':global vpn_gateway "10.10.10.17"\n';
    rosScript += ':global vpn_routing_mark "vpn_mark"\n\n';

    // Setup routing infrastructure
    rosScript += "# === Routing Infrastructure Setup ===\n\n";

    // Add routing table
    rosScript += "# Create routing table for VPN traffic\n";
    rosScript += '/routing table add name=vpn_table fib comment="VPN routing table"\n\n';

    // Add mangle rules for marking traffic
    rosScript += "# Mark connections and routing for vpn_list address-list\n";
    rosScript +=
      '/ip firewall mangle add chain=prerouting src-address-list=vpn_list action=mark-connection new-connection-mark=vpn_conn passthrough=yes comment="Mark VPN connections (src)"\n';
    rosScript +=
      '/ip firewall mangle add chain=prerouting dst-address-list=vpn_list action=mark-connection new-connection-mark=vpn_conn passthrough=yes comment="Mark VPN connections (dst)"\n';
    rosScript +=
      '/ip firewall mangle add chain=prerouting connection-mark=vpn_conn action=mark-routing new-routing-mark=$vpn_routing_mark passthrough=no comment="Mark routing for VPN traffic"\n\n';

    // Add route to VPN gateway
    rosScript += "# Add route via VPN gateway\n";
    rosScript +=
      '/ip route add dst-address=0.0.0.0/0 gateway=$vpn_gateway routing-table=vpn_table comment="Route all VPN traffic via gateway"\n\n';

    // Add routing rule
    rosScript += "# Route marked traffic through VPN routing table\n";
    rosScript +=
      '/routing rule add src-address-list=vpn_list table=vpn_table comment="Use VPN table for marked source"\n';
    rosScript +=
      '/routing rule add dst-address-list=vpn_list table=vpn_table comment="Use VPN table for marked destination"\n\n';

    rosScript += "# === DNS and Address List Entries ===\n\n";

    const processedDomains = new Set<string>();
    const processedIps = new Set<string>();

    for (const link of links) {
      const rawUrl = convertToRawListUrl(link.url);
      rosScript += `# --- Source: ${link.name} ---\n`;
      rosScript += `# URL: ${rawUrl}\n`;

      try {
        const response = await fetch(rawUrl);
        if (!response.ok) {
          rosScript += `# Error: Failed to fetch rules (${response.status})\n\n`;
          continue;
        }

        const text = await response.text();
        const lines = text.split("\n");

        for (const line of lines) {
          const trimmed = line.trim();
          if (!trimmed || trimmed.startsWith("#")) continue;

          const parts = trimmed.split(",");
          if (parts.length < 2) continue;

          const type = parts[0];
          const value = parts[1];

          if (type === "DOMAIN") {
            if (processedDomains.has(value)) continue;
            processedDomains.add(value);
            rosScript += `/ip dns static add name=${value} type=FWD forward-to=$vpn_dns_server address-list=vpn_list match-subdomain=no comment="vpn-dns: ${link.name}"\n`;
          } else if (type === "DOMAIN-SUFFIX") {
            if (processedDomains.has(value)) continue;
            processedDomains.add(value);
            rosScript += `/ip dns static add name=${value} type=FWD forward-to=$vpn_dns_server address-list=vpn_list match-subdomain=yes comment="vpn-dns: ${link.name}"\n`;
          } else if (type === "IP-CIDR" || type === "IP-CIDR6") {
            if (processedIps.has(value)) continue;
            processedIps.add(value);
            rosScript += `/ip firewall address-list add address=${value} comment="vpn: ${link.name}" list=vpn_list\n`;
          }
        }
        rosScript += "\n";
      } catch (err) {
        rosScript += `# Error: ${err instanceof Error ? err.message : String(err)}\n\n`;
      }
    }

    // Return the script as a file download
    return new Response(rosScript, {
      headers: {
        "Content-Type": "text/plain",
        "Content-Disposition": 'attachment; filename="lilibox-export.rsc"',
      },
    });
  } catch (error) {
    console.error("Export ROS error:", error);
    return NextResponse.json({ error: "Failed to generate ROS script" }, { status: 500 });
  }
}
